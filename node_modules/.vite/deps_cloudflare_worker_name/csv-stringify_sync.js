import "./chunk-HKJ2B2AA.js";

// node_modules/csv-stringify/lib/utils/get.js
var charCodeOfDot = ".".charCodeAt(0);
var reEscapeChar = /\\(\\)?/g;
var rePropName = RegExp(
  // Match anything that isn't a dot or bracket.
  `[^.[\\]]+|\\[(?:([^"'][^[]*)|(["'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|$))`,
  "g"
);
var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/;
var reIsPlainProp = /^\w*$/;
var getTag = function(value) {
  return Object.prototype.toString.call(value);
};
var isSymbol = function(value) {
  const type = typeof value;
  return type === "symbol" || type === "object" && value && getTag(value) === "[object Symbol]";
};
var isKey = function(value, object) {
  if (Array.isArray(value)) {
    return false;
  }
  const type = typeof value;
  if (type === "number" || type === "symbol" || type === "boolean" || !value || isSymbol(value)) {
    return true;
  }
  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
};
var stringToPath = function(string) {
  const result = [];
  if (string.charCodeAt(0) === charCodeOfDot) {
    result.push("");
  }
  string.replace(rePropName, function(match, expression, quote, subString) {
    let key = match;
    if (quote) {
      key = subString.replace(reEscapeChar, "$1");
    } else if (expression) {
      key = expression.trim();
    }
    result.push(key);
  });
  return result;
};
var castPath = function(value, object) {
  if (Array.isArray(value)) {
    return value;
  } else {
    return isKey(value, object) ? [value] : stringToPath(value);
  }
};
var toKey = function(value) {
  if (typeof value === "string" || isSymbol(value)) return value;
  const result = `${value}`;
  return result == "0" && 1 / value == -INFINITY ? "-0" : result;
};
var get = function(object, path) {
  path = castPath(path, object);
  let index = 0;
  const length = path.length;
  while (object != null && index < length) {
    object = object[toKey(path[index++])];
  }
  return index && index === length ? object : void 0;
};

// node_modules/csv-stringify/lib/utils/is_object.js
var is_object = function(obj) {
  return typeof obj === "object" && obj !== null && !Array.isArray(obj);
};

// node_modules/csv-stringify/lib/api/normalize_columns.js
var normalize_columns = function(columns) {
  if (columns === void 0 || columns === null) {
    return [void 0, void 0];
  }
  if (typeof columns !== "object") {
    return [Error('Invalid option "columns": expect an array or an object')];
  }
  if (!Array.isArray(columns)) {
    const newcolumns = [];
    for (const k in columns) {
      newcolumns.push({
        key: k,
        header: columns[k]
      });
    }
    columns = newcolumns;
  } else {
    const newcolumns = [];
    for (const column of columns) {
      if (typeof column === "string") {
        newcolumns.push({
          key: column,
          header: column
        });
      } else if (typeof column === "object" && column !== null && !Array.isArray(column)) {
        if (!column.key) {
          return [
            Error('Invalid column definition: property "key" is required')
          ];
        }
        if (column.header === void 0) {
          column.header = column.key;
        }
        newcolumns.push(column);
      } else {
        return [
          Error("Invalid column definition: expect a string or an object")
        ];
      }
    }
    columns = newcolumns;
  }
  return [void 0, columns];
};

// node_modules/csv-stringify/lib/api/CsvError.js
var CsvError = class _CsvError extends Error {
  constructor(code, message, ...contexts) {
    if (Array.isArray(message)) message = message.join(" ");
    super(message);
    if (Error.captureStackTrace !== void 0) {
      Error.captureStackTrace(this, _CsvError);
    }
    this.code = code;
    for (const context of contexts) {
      for (const key in context) {
        const value = context[key];
        this[key] = Buffer.isBuffer(value) ? value.toString() : value == null ? value : JSON.parse(JSON.stringify(value));
      }
    }
  }
};

// node_modules/csv-stringify/lib/utils/underscore.js
var underscore = function(str) {
  return str.replace(/([A-Z])/g, function(_, match) {
    return "_" + match.toLowerCase();
  });
};

// node_modules/csv-stringify/lib/api/normalize_options.js
var normalize_options = function(opts) {
  const options = {};
  for (const opt in opts) {
    options[underscore(opt)] = opts[opt];
  }
  if (options.bom === void 0 || options.bom === null || options.bom === false) {
    options.bom = false;
  } else if (options.bom !== true) {
    return [
      new CsvError("CSV_OPTION_BOOLEAN_INVALID_TYPE", [
        "option `bom` is optional and must be a boolean value,",
        `got ${JSON.stringify(options.bom)}`
      ])
    ];
  }
  if (options.delimiter === void 0 || options.delimiter === null) {
    options.delimiter = ",";
  } else if (Buffer.isBuffer(options.delimiter)) {
    options.delimiter = options.delimiter.toString();
  } else if (typeof options.delimiter !== "string") {
    return [
      new CsvError("CSV_OPTION_DELIMITER_INVALID_TYPE", [
        "option `delimiter` must be a buffer or a string,",
        `got ${JSON.stringify(options.delimiter)}`
      ])
    ];
  }
  if (options.quote === void 0 || options.quote === null) {
    options.quote = '"';
  } else if (options.quote === true) {
    options.quote = '"';
  } else if (options.quote === false) {
    options.quote = "";
  } else if (Buffer.isBuffer(options.quote)) {
    options.quote = options.quote.toString();
  } else if (typeof options.quote !== "string") {
    return [
      new CsvError("CSV_OPTION_QUOTE_INVALID_TYPE", [
        "option `quote` must be a boolean, a buffer or a string,",
        `got ${JSON.stringify(options.quote)}`
      ])
    ];
  }
  if (options.quoted === void 0 || options.quoted === null) {
    options.quoted = false;
  } else {
  }
  if (options.escape_formulas === void 0 || options.escape_formulas === null) {
    options.escape_formulas = false;
  } else if (typeof options.escape_formulas !== "boolean") {
    return [
      new CsvError("CSV_OPTION_ESCAPE_FORMULAS_INVALID_TYPE", [
        "option `escape_formulas` must be a boolean,",
        `got ${JSON.stringify(options.escape_formulas)}`
      ])
    ];
  }
  if (options.quoted_empty === void 0 || options.quoted_empty === null) {
    options.quoted_empty = void 0;
  } else {
  }
  if (options.quoted_match === void 0 || options.quoted_match === null || options.quoted_match === false) {
    options.quoted_match = null;
  } else if (!Array.isArray(options.quoted_match)) {
    options.quoted_match = [options.quoted_match];
  }
  if (options.quoted_match) {
    for (const quoted_match of options.quoted_match) {
      const isString = typeof quoted_match === "string";
      const isRegExp = quoted_match instanceof RegExp;
      if (!isString && !isRegExp) {
        return [
          Error(
            `Invalid Option: quoted_match must be a string or a regex, got ${JSON.stringify(quoted_match)}`
          )
        ];
      }
    }
  }
  if (options.quoted_string === void 0 || options.quoted_string === null) {
    options.quoted_string = false;
  } else {
  }
  if (options.eof === void 0 || options.eof === null) {
    options.eof = true;
  } else {
  }
  if (options.escape === void 0 || options.escape === null) {
    options.escape = '"';
  } else if (Buffer.isBuffer(options.escape)) {
    options.escape = options.escape.toString();
  } else if (typeof options.escape !== "string") {
    return [
      Error(
        `Invalid Option: escape must be a buffer or a string, got ${JSON.stringify(options.escape)}`
      )
    ];
  }
  if (options.escape.length > 1) {
    return [
      Error(
        `Invalid Option: escape must be one character, got ${options.escape.length} characters`
      )
    ];
  }
  if (options.header === void 0 || options.header === null) {
    options.header = false;
  } else {
  }
  const [errColumns, columns] = normalize_columns(options.columns);
  if (errColumns !== void 0) return [errColumns];
  options.columns = columns;
  if (options.quoted === void 0 || options.quoted === null) {
    options.quoted = false;
  } else {
  }
  if (options.cast === void 0 || options.cast === null) {
    options.cast = {};
  } else {
  }
  if (options.cast.bigint === void 0 || options.cast.bigint === null) {
    options.cast.bigint = (value) => "" + value;
  }
  if (options.cast.boolean === void 0 || options.cast.boolean === null) {
    options.cast.boolean = (value) => value ? "1" : "";
  }
  if (options.cast.date === void 0 || options.cast.date === null) {
    options.cast.date = (value) => "" + value.getTime();
  }
  if (options.cast.number === void 0 || options.cast.number === null) {
    options.cast.number = (value) => "" + value;
  }
  if (options.cast.object === void 0 || options.cast.object === null) {
    options.cast.object = (value) => JSON.stringify(value);
  }
  if (options.cast.string === void 0 || options.cast.string === null) {
    options.cast.string = function(value) {
      return value;
    };
  }
  if (options.on_record !== void 0 && typeof options.on_record !== "function") {
    return [Error(`Invalid Option: "on_record" must be a function.`)];
  }
  if (options.record_delimiter === void 0 || options.record_delimiter === null) {
    options.record_delimiter = "\n";
  } else if (Buffer.isBuffer(options.record_delimiter)) {
    options.record_delimiter = options.record_delimiter.toString();
  } else if (typeof options.record_delimiter !== "string") {
    return [
      Error(
        `Invalid Option: record_delimiter must be a buffer or a string, got ${JSON.stringify(options.record_delimiter)}`
      )
    ];
  }
  switch (options.record_delimiter) {
    case "unix":
      options.record_delimiter = "\n";
      break;
    case "mac":
      options.record_delimiter = "\r";
      break;
    case "windows":
      options.record_delimiter = "\r\n";
      break;
    case "ascii":
      options.record_delimiter = "";
      break;
    case "unicode":
      options.record_delimiter = "\u2028";
      break;
  }
  return [void 0, options];
};

// node_modules/csv-stringify/lib/api/index.js
var bom_utf8 = Buffer.from([239, 187, 191]);
var stringifier = function(options, state, info) {
  return {
    options,
    state,
    info,
    __transform: function(chunk, push) {
      if (!Array.isArray(chunk) && typeof chunk !== "object") {
        return Error(
          `Invalid Record: expect an array or an object, got ${JSON.stringify(chunk)}`
        );
      }
      if (this.info.records === 0) {
        if (Array.isArray(chunk)) {
          if (this.options.header === true && this.options.columns === void 0) {
            return Error(
              "Undiscoverable Columns: header option requires column option or object records"
            );
          }
        } else if (this.options.columns === void 0) {
          const [err2, columns] = normalize_columns(Object.keys(chunk));
          if (err2) return;
          this.options.columns = columns;
        }
      }
      if (this.info.records === 0) {
        this.bom(push);
        const err2 = this.headers(push);
        if (err2) return err2;
      }
      try {
        if (this.options.on_record) {
          this.options.on_record(chunk, this.info.records);
        }
      } catch (err2) {
        return err2;
      }
      let err, chunk_string;
      if (this.options.eof) {
        [err, chunk_string] = this.stringify(chunk);
        if (err) return err;
        if (chunk_string === void 0) {
          return;
        } else {
          chunk_string = chunk_string + this.options.record_delimiter;
        }
      } else {
        [err, chunk_string] = this.stringify(chunk);
        if (err) return err;
        if (chunk_string === void 0) {
          return;
        } else {
          if (this.options.header || this.info.records) {
            chunk_string = this.options.record_delimiter + chunk_string;
          }
        }
      }
      this.info.records++;
      push(chunk_string);
    },
    stringify: function(chunk, chunkIsHeader = false) {
      if (typeof chunk !== "object") {
        return [void 0, chunk];
      }
      const { columns } = this.options;
      const record = [];
      if (Array.isArray(chunk)) {
        if (columns) {
          chunk.splice(columns.length);
        }
        for (let i = 0; i < chunk.length; i++) {
          const field = chunk[i];
          const [err, value] = this.__cast(field, {
            index: i,
            column: i,
            records: this.info.records,
            header: chunkIsHeader
          });
          if (err) return [err];
          record[i] = [value, field];
        }
      } else {
        for (let i = 0; i < columns.length; i++) {
          const field = get(chunk, columns[i].key);
          const [err, value] = this.__cast(field, {
            index: i,
            column: columns[i].key,
            records: this.info.records,
            header: chunkIsHeader
          });
          if (err) return [err];
          record[i] = [value, field];
        }
      }
      let csvrecord = "";
      for (let i = 0; i < record.length; i++) {
        let options2, err;
        let [value, field] = record[i];
        if (typeof value === "string") {
          options2 = this.options;
        } else if (is_object(value)) {
          options2 = value;
          value = options2.value;
          delete options2.value;
          if (typeof value !== "string" && value !== void 0 && value !== null) {
            if (err)
              return [
                Error(
                  `Invalid Casting Value: returned value must return a string, null or undefined, got ${JSON.stringify(value)}`
                )
              ];
          }
          options2 = { ...this.options, ...options2 };
          [err, options2] = normalize_options(options2);
          if (err !== void 0) {
            return [err];
          }
        } else if (value === void 0 || value === null) {
          options2 = this.options;
        } else {
          return [
            Error(
              `Invalid Casting Value: returned value must return a string, an object, null or undefined, got ${JSON.stringify(value)}`
            )
          ];
        }
        const {
          delimiter,
          escape,
          quote,
          quoted,
          quoted_empty,
          quoted_string,
          quoted_match,
          record_delimiter,
          escape_formulas
        } = options2;
        if ("" === value && "" === field) {
          let quotedMatch = quoted_match && quoted_match.filter((quoted_match2) => {
            if (typeof quoted_match2 === "string") {
              return value.indexOf(quoted_match2) !== -1;
            } else {
              return quoted_match2.test(value);
            }
          });
          quotedMatch = quotedMatch && quotedMatch.length > 0;
          const shouldQuote = quotedMatch || true === quoted_empty || true === quoted_string && false !== quoted_empty;
          if (shouldQuote === true) {
            value = quote + value + quote;
          }
          csvrecord += value;
        } else if (value) {
          if (typeof value !== "string") {
            return [
              Error(
                `Formatter must return a string, null or undefined, got ${JSON.stringify(value)}`
              )
            ];
          }
          const containsdelimiter = delimiter.length && value.indexOf(delimiter) >= 0;
          const containsQuote = quote !== "" && value.indexOf(quote) >= 0;
          const containsEscape = value.indexOf(escape) >= 0 && escape !== quote;
          const containsRecordDelimiter = value.indexOf(record_delimiter) >= 0;
          const quotedString = quoted_string && typeof field === "string";
          let quotedMatch = quoted_match && quoted_match.filter((quoted_match2) => {
            if (typeof quoted_match2 === "string") {
              return value.indexOf(quoted_match2) !== -1;
            } else {
              return quoted_match2.test(value);
            }
          });
          quotedMatch = quotedMatch && quotedMatch.length > 0;
          if (escape_formulas) {
            switch (value[0]) {
              case "=":
              case "+":
              case "-":
              case "@":
              case "	":
              case "\r":
              case "＝":
              // Unicode '='
              case "＋":
              // Unicode '+'
              case "－":
              // Unicode '-'
              case "＠":
                value = `'${value}`;
                break;
            }
          }
          const shouldQuote = containsQuote === true || containsdelimiter || containsRecordDelimiter || quoted || quotedString || quotedMatch;
          if (shouldQuote === true && containsEscape === true) {
            const regexp = escape === "\\" ? new RegExp(escape + escape, "g") : new RegExp(escape, "g");
            value = value.replace(regexp, escape + escape);
          }
          if (containsQuote === true) {
            const regexp = new RegExp(quote, "g");
            value = value.replace(regexp, escape + quote);
          }
          if (shouldQuote === true) {
            value = quote + value + quote;
          }
          csvrecord += value;
        } else if (quoted_empty === true || field === "" && quoted_string === true && quoted_empty !== false) {
          csvrecord += quote + quote;
        }
        if (i !== record.length - 1) {
          csvrecord += delimiter;
        }
      }
      return [void 0, csvrecord];
    },
    bom: function(push) {
      if (this.options.bom !== true) {
        return;
      }
      push(bom_utf8);
    },
    headers: function(push) {
      if (this.options.header === false) {
        return;
      }
      if (this.options.columns === void 0) {
        return;
      }
      let err;
      let headers = this.options.columns.map((column) => column.header);
      if (this.options.eof) {
        [err, headers] = this.stringify(headers, true);
        headers += this.options.record_delimiter;
      } else {
        [err, headers] = this.stringify(headers);
      }
      if (err) return err;
      push(headers);
    },
    __cast: function(value, context) {
      const type = typeof value;
      try {
        if (type === "string") {
          return [void 0, this.options.cast.string(value, context)];
        } else if (type === "bigint") {
          return [void 0, this.options.cast.bigint(value, context)];
        } else if (type === "number") {
          return [void 0, this.options.cast.number(value, context)];
        } else if (type === "boolean") {
          return [void 0, this.options.cast.boolean(value, context)];
        } else if (value instanceof Date) {
          return [void 0, this.options.cast.date(value, context)];
        } else if (type === "object" && value !== null) {
          return [void 0, this.options.cast.object(value, context)];
        } else {
          return [void 0, value, value];
        }
      } catch (err) {
        return [err];
      }
    }
  };
};

// node_modules/csv-stringify/lib/sync.js
var stringify = function(records, opts = {}) {
  const data = [];
  const [err, options] = normalize_options(opts);
  if (err !== void 0) throw err;
  const state = {
    stop: false
  };
  const info = {
    records: 0
  };
  const api = stringifier(options, state, info);
  for (const record of records) {
    const err2 = api.__transform(record, function(record2) {
      data.push(record2);
    });
    if (err2 !== void 0) throw err2;
  }
  if (data.length === 0) {
    api.bom((d) => {
      data.push(d);
    });
    const err2 = api.headers((headers) => {
      data.push(headers);
    });
    if (err2 !== void 0) throw err2;
  }
  return data.join("");
};
export {
  stringify
};
//# sourceMappingURL=csv-stringify_sync.js.map
