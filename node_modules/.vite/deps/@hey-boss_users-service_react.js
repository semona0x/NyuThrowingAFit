import {
  require_jsx_runtime
} from "./chunk-FVZZTKNL.js";
import {
  __toESM,
  require_react
} from "./chunk-N6MYFXC3.js";

// node_modules/@hey-boss/users-service/dist/react.js
var import_jsx_runtime = __toESM(require_jsx_runtime());
var import_react = __toESM(require_react());
var AuthContext = (0, import_react.createContext)(null);
var POPUP_WIDTH = 500;
var POPUP_HEIGHT = 600;
function AuthProvider({ children }) {
  const [user, setUser] = (0, import_react.useState)(null);
  const userRef = (0, import_react.useRef)(null);
  const exchangeRef = (0, import_react.useRef)(null);
  const popupRef = (0, import_react.useRef)(null);
  const popupPromiseRef = (0, import_react.useRef)(null);
  const [isPending, setIsPending] = (0, import_react.useState)(true);
  const [isFetching, setIsFetching] = (0, import_react.useState)(false);
  const fetchUser = (0, import_react.useCallback)(async () => {
    if (userRef.current)
      return userRef.current;
    userRef.current = (async () => {
      setIsFetching(true);
      try {
        const response = await fetch("/api/users/me");
        if (!response.ok) {
          throw new Error(`Failed to fetch user: API responded with HTTP status ${response.status}`);
        }
        const user2 = await response.json();
        setUser(user2);
      } catch (error) {
        throw error;
      } finally {
        setIsFetching(false);
        userRef.current = null;
      }
    })();
    return userRef.current;
  }, []);
  const logout = (0, import_react.useCallback)(async () => {
    try {
      setUser(null);
      await fetch("/api/logout");
    } catch (error) {
      console.error("Failed to logout:", error);
    }
  }, []);
  const redirectToLogin = (0, import_react.useCallback)(async () => {
    try {
      const originUrl = new URL(window.location.href).origin;
      const response = await fetch(`/api/oauth/google/redirect_url?originUrl=${originUrl}`);
      if (!response.ok) {
        throw new Error(`Failed to get login redirect URL: API responded with HTTP status ${response.status}`);
      }
      const { redirectUrl } = await response.json();
      window.location.href = redirectUrl;
    } catch (error) {
      console.error(error);
    }
  }, []);
  const popupLogin = (0, import_react.useCallback)(async () => {
    try {
      if (popupPromiseRef.current) {
        return popupPromiseRef.current;
      }
      const originUrl = new URL(window.location.href).origin;
      const response = await fetch(`/api/oauth/google/redirect_url?originUrl=${originUrl}`);
      if (!response.ok) {
        throw new Error(`Failed to get login redirect URL: API responded with HTTP status ${response.status}`);
      }
      const { redirectUrl } = await response.json();
      const left = (window.screen.width - POPUP_WIDTH) / 2;
      const top = (window.screen.height - POPUP_HEIGHT) / 2;
      popupPromiseRef.current = new Promise((resolve, reject) => {
        popupRef.current = window.open(redirectUrl, "google-oauth", `width=${POPUP_WIDTH},height=${POPUP_HEIGHT},left=${left},top=${top},scrollbars=yes,resizable=yes`);
        if (!popupRef.current) {
          reject(new Error("Failed to open popup window"));
          return;
        }
        let isProcessed = false;
        let checkClosedInterval;
        const handleMessage = async (event) => {
          if (event.origin !== window.location.origin)
            return;
          if (event.data.type === "GOOGLE_OAUTH_SUCCESS") {
            const { code } = event.data;
            isProcessed = true;
            try {
              await exchangeCodeForSessionToken(code);
              resolve();
            } catch (error) {
              reject(error);
            } finally {
              cleanup();
            }
          } else if (event.data.type === "GOOGLE_OAUTH_ERROR") {
            isProcessed = true;
            reject(new Error(event.data.error || "OAuth authorization failed"));
            cleanup();
          }
        };
        const checkClosed = () => {
          if (popupRef.current && popupRef.current.closed && !isProcessed) {
            reject(new Error("User cancelled the login process"));
            cleanup();
          } else if (popupRef.current && !popupRef.current.closed) {
            checkClosedInterval = setTimeout(checkClosed, 1e3);
          }
        };
        const cleanup = () => {
          window.removeEventListener("message", handleMessage);
          if (checkClosedInterval) {
            clearTimeout(checkClosedInterval);
          }
          if (popupRef.current && !popupRef.current.closed) {
            popupRef.current.close();
          }
          popupRef.current = null;
          popupPromiseRef.current = null;
        };
        window.addEventListener("message", handleMessage);
        window.addEventListener("storage", async (event) => {
          isProcessed = true;
          if (event.key === "GOOGLE_OAUTH_SUCCESS" && event.newValue) {
            try {
              await exchangeCodeForSessionToken(event.newValue);
              resolve();
            } catch (error) {
              reject(error);
            } finally {
              cleanup();
              localStorage.removeItem("GOOGLE_OAUTH_SUCCESS");
            }
          }
          if (event.key === "GOOGLE_OAUTH_ERROR" && event.newValue) {
            reject(new Error(event.newValue || "OAuth authorization failed"));
            cleanup();
            localStorage.removeItem("GOOGLE_OAUTH_ERROR");
          }
        });
        checkClosed();
      });
      return popupPromiseRef.current;
    } catch (error) {
      console.error("Popup login failed:", error);
      throw error;
    }
  }, [fetchUser]);
  const exchangeCodeForSessionToken = (0, import_react.useCallback)((code) => {
    if (exchangeRef.current)
      return exchangeRef.current;
    exchangeRef.current = (async (code2) => {
      try {
        const response = await fetch("/api/sessions", {
          method: "POST",
          headers: {
            "Content-Type": "application/json"
          },
          body: JSON.stringify({ code: code2 })
        });
        if (!response.ok) {
          throw new Error(`Failed to exchange code for session token: API responded with HTTP status ${response.status}`);
        }
        await fetchUser();
      } catch (error) {
        console.error(error);
      } finally {
        exchangeRef.current = null;
      }
    })(code);
    return exchangeRef.current;
  }, [fetchUser]);
  const notifyParentWindowWithOAuthCode = () => {
    const urlParams = new URLSearchParams(window.location.search);
    const code = urlParams.get("code");
    const error = urlParams.get("error");
    const errorDescription = urlParams.get("error_description");
    if (!code && !error) {
      throw new Error("No OAuth code or error found in URL parameters.");
    }
    const handleSuccess = (successCode) => {
      if (window.opener) {
        window.opener.postMessage({ type: "GOOGLE_OAUTH_SUCCESS", code: successCode }, window.location.origin);
      } else {
        localStorage.setItem("GOOGLE_OAUTH_SUCCESS", successCode);
      }
    };
    const handleError = (errorMsg) => {
      if (window.opener) {
        window.opener.postMessage({ type: "GOOGLE_OAUTH_ERROR", error: errorMsg }, window.location.origin);
      } else {
        localStorage.setItem("GOOGLE_OAUTH_ERROR", errorMsg);
      }
    };
    if (code) {
      handleSuccess(code);
    } else if (error) {
      handleError(errorDescription || error);
    }
    window.close();
  };
  const sendOTP = (0, import_react.useCallback)(async (email) => {
    const response = await fetch("/api/send-otp", {
      method: "POST",
      headers: {
        "Content-Type": "application/json"
      },
      body: JSON.stringify({ email })
    });
    const data = await response.json();
    if (data.error) {
      throw new Error(data.error);
    }
    return data;
  }, []);
  const verifyOTP = (0, import_react.useCallback)(async (email, otp) => {
    const response = await fetch("/api/verify-otp", {
      method: "POST",
      headers: {
        "Content-Type": "application/json"
      },
      body: JSON.stringify({ email, otp })
    });
    return response.json().then((data) => {
      if (data.error) {
        throw new Error(data.error);
      }
      fetchUser();
      return data;
    });
  }, []);
  (0, import_react.useEffect)(() => {
    fetchUser().then(() => setIsPending(false), () => setIsPending(false));
  }, []);
  const contextValue = {
    user,
    isPending,
    isFetching,
    fetchUser,
    redirectToLogin,
    popupLogin,
    exchangeCodeForSessionToken,
    notifyParentWindowWithOAuthCode,
    logout,
    sendOTP,
    verifyOTP
  };
  return (0, import_jsx_runtime.jsx)(AuthContext.Provider, {
    value: contextValue,
    children
  });
}
function useAuth() {
  const context = (0, import_react.useContext)(AuthContext);
  if (!context) {
    throw new Error("useAuth must be used within a AuthProvider");
  }
  return context;
}
export {
  AuthProvider,
  useAuth
};
//# sourceMappingURL=@hey-boss_users-service_react.js.map
