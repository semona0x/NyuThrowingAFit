/// <reference types="hono" />
import { getCookie } from "hono/cookie";
import { createMiddleware } from "hono/factory";
import { HTTPException } from "hono/http-exception";
export const DEFAULT_USERS_SERVICE_API_URL = "https://user-server.dev-73d.workers.dev";
export const SESSION_TOKEN_COOKIE_NAME = "heyboss_session_token";
export const SUPPORTED_OAUTH_PROVIDERS = ["google"];
/**
 * Fetch the OAuth redirect URL from the Mocha Users Service.
 * @param provider - The OAuth provider to use (currently only "google" is supported)
 * @param options - Configuration options including origin URL
 * @returns The redirect URL to initiate the OAuth flow
 */
export async function getOAuthRedirectUrl(provider, options) {
    if (!SUPPORTED_OAUTH_PROVIDERS.includes(provider)) {
        throw new Error(`Unsupported OAuth provider: ${provider}`);
    }
    const response = await fetch(`${DEFAULT_USERS_SERVICE_API_URL}/oauth/${provider}/redirect_url?originUrl=${options.originUrl}`, {
        method: "GET",
        headers: {
            "Content-Type": "application/json",
        },
    });
    if (!response.ok) {
        throw new Error(`Failed to get redirect URL for provider ${provider}: ${response.statusText}`);
    }
    const { redirectUrl } = await response.json();
    return redirectUrl;
}
/**
 * Exchanges a code for a session token using the Mocha Users Service.
 * @param code - The OAuth code received after successful authentication
 * @returns The session token to use for authenticated requests
 */
export async function exchangeCodeForSessionToken(code, projectId = "") {
    const response = await fetch(`${DEFAULT_USERS_SERVICE_API_URL}/sessions`, {
        method: "POST",
        headers: {
            "Content-Type": "application/json",
        },
        body: JSON.stringify({ code, projectId }),
    });
    if (!response.ok) {
        throw new Error(`Failed to exchange code for session token: ${response.statusText}`);
    }
    const { sessionToken } = await response.json();
    return sessionToken;
}
/**
 * Fetch the current user by their session token from the Mocha Users Service.
 * @param sessionToken - The session token obtained from exchangeCodeForSessionToken
 * @returns The user object or null if the session is invalid
 */
export async function getCurrentUser(sessionToken) {
    const response = await fetch(`${DEFAULT_USERS_SERVICE_API_URL}/users/me`, {
        method: "GET",
        headers: {
            Authorization: `Bearer ${sessionToken}`,
        },
    });
    if (!response.ok) {
        return null;
    }
    const { data: user } = await response.json();
    return user;
}
/**
 * Delete the current session in the Mocha Users Service when logging out.
 * @param sessionToken - The users session token from their cookie.
 */
export async function deleteSession(sessionToken) {
    await fetch(`${DEFAULT_USERS_SERVICE_API_URL}/sessions`, {
        method: "DELETE",
        headers: {
            Authorization: `Bearer ${sessionToken}`,
        },
    });
}
/**
 * Hono middleware that authenticates requests against the Mocha Users Service.
 *
 * This middleware requests the current user using the session token stored in
 * cookies. If the request fails to return a valid user object, the middleware
 * throws an HTTPException with status 401. On success, it sets the authenticated
 * user in the Hono context for use in subsequent route handlers.
 *
 * Use this to protect routes and load the current user.
 *
 * @throws {HTTPException} 401 - When session token is invalid or not provided
 *
 * @example
 *
 * // Fetch the authenticated user's todos.
 * // Doesn't execute if the user is not authenticated.
 * app.get("/api/todos", authMiddleware, async (c) => {
 *   const user = c.get("user");
 *
 *   const { results } = await c.env.DB.prepare(
 *     "SELECT * FROM todos WHERE user_id = ? ORDER BY created_at DESC"
 *   )
 *     .bind(user.id)
 *     .all();
 *
 *   return c.json(results);
 * });
 */
export const authMiddleware = createMiddleware(async (c, next) => {
    const sessionToken = getCookie(c, SESSION_TOKEN_COOKIE_NAME);
    if (typeof sessionToken !== "string") {
        return c.json({ error: "Unauthorized" }, 401);
    }
    const user = await getCurrentUser(sessionToken);
    if (!user) {
        throw new HTTPException(401, { message: "Invalid session token" });
    }
    c.set("user", user);
    await next();
});
export async function sendOTP(email, projectId) {
    const response = await fetch(`${DEFAULT_USERS_SERVICE_API_URL}/auth/send-otp`, {
        method: "POST",
        headers: {
            "Content-Type": "application/json",
        },
        body: JSON.stringify({ email, projectId }),
    });
    return response.json();
}
export async function verifyOTP(email, otp) {
    const response = await fetch(`${DEFAULT_USERS_SERVICE_API_URL}/auth/verify-otp`, {
        method: "POST",
        headers: {
            "Content-Type": "application/json",
        },
        body: JSON.stringify({ email, otp }),
    });
    return response.json();
}
