import { jsx as _jsx } from "react/jsx-runtime";
import { createContext, useCallback, useContext, useEffect, useRef, useState, } from "react";
const AuthContext = createContext(null);
// 添加弹窗相关常量
const POPUP_WIDTH = 500;
const POPUP_HEIGHT = 600;
/**
 * A React context provider that manages authentication state and related actions.
 * Install this at the top of the React component tree to provide authentication
 * and user management functionality. This is needed for the `useAuth` hook to work.
 *
 * This will always fetch the `user` object on mount.
 *
 * @example
 * import { AuthProvider } from '@hey-boss/users-service/react';
 *
 * // React Router example
 * export default function App() {
 *   return (
 *     <AuthProvider>
 *       <Router>
 *         <Routes>
 *           <Route path="/" element={<HomePage />} />
 *           <Route path="/auth/callback" element={<AuthCallbackPage />} />
 *         </Routes>
 *       </Router>
 *     </AuthProvider>
 *   );
 * }
 */
export function AuthProvider({ children }) {
    const [user, setUser] = useState(null);
    // Use these to dedup requests. This is mostly for avoiding multiple
    // calls from useEffects in dev, which could cause wonky behavior with
    // the loading states or problems when exchanging code for session token.
    const userRef = useRef(null);
    const exchangeRef = useRef(null);
    const popupRef = useRef(null);
    const popupPromiseRef = useRef(null);
    const [isPending, setIsPending] = useState(true);
    const [isFetching, setIsFetching] = useState(false);
    const fetchUser = useCallback(async () => {
        if (userRef.current)
            return userRef.current;
        userRef.current = (async () => {
            setIsFetching(true);
            try {
                const response = await fetch("/api/users/me");
                if (!response.ok) {
                    throw new Error(`Failed to fetch user: API responded with HTTP status ${response.status}`);
                }
                const user = await response.json();
                setUser(user);
            }
            catch (error) {
                throw error;
            }
            finally {
                setIsFetching(false);
                userRef.current = null;
            }
        })();
        return userRef.current;
    }, []);
    const logout = useCallback(async () => {
        try {
            setUser(null);
            await fetch("/api/logout");
        }
        catch (error) {
            console.error("Failed to logout:", error);
        }
    }, []);
    const redirectToLogin = useCallback(async () => {
        try {
            const originUrl = new URL(window.location.href).origin;
            const response = await fetch(`/api/oauth/google/redirect_url?originUrl=${originUrl}`);
            if (!response.ok) {
                throw new Error(`Failed to get login redirect URL: API responded with HTTP status ${response.status}`);
            }
            const { redirectUrl } = await response.json();
            window.location.href = redirectUrl;
        }
        catch (error) {
            console.error(error);
        }
    }, []);
    // 弹窗登录函数
    const popupLogin = useCallback(async () => {
        try {
            // 如果已经有弹窗打开，直接返回现有promise
            if (popupPromiseRef.current) {
                return popupPromiseRef.current;
            }
            const originUrl = new URL(window.location.href).origin;
            const response = await fetch(`/api/oauth/google/redirect_url?originUrl=${originUrl}`);
            if (!response.ok) {
                throw new Error(`Failed to get login redirect URL: API responded with HTTP status ${response.status}`);
            }
            const { redirectUrl } = await response.json();
            // 创建弹窗
            const left = (window.screen.width - POPUP_WIDTH) / 2;
            const top = (window.screen.height - POPUP_HEIGHT) / 2;
            popupPromiseRef.current = new Promise((resolve, reject) => {
                // 打开弹窗
                popupRef.current = window.open(redirectUrl, "google-oauth", `width=${POPUP_WIDTH},height=${POPUP_HEIGHT},left=${left},top=${top},scrollbars=yes,resizable=yes`);
                if (!popupRef.current) {
                    reject(new Error("Failed to open popup window"));
                    return;
                }
                // 添加标志位来跟踪是否已处理
                let isProcessed = false;
                let checkClosedInterval;
                // 监听弹窗消息
                const handleMessage = async (event) => {
                    // 验证消息来源
                    if (event.origin !== window.location.origin)
                        return;
                    if (event.data.type === "GOOGLE_OAUTH_SUCCESS") {
                        const { code } = event.data;
                        isProcessed = true; // 标记为已处理
                        try {
                            // 交换code获取session token
                            await exchangeCodeForSessionToken(code);
                            resolve();
                        }
                        catch (error) {
                            reject(error);
                        }
                        finally {
                            cleanup();
                        }
                    }
                    else if (event.data.type === "GOOGLE_OAUTH_ERROR") {
                        isProcessed = true; // 标记为已处理
                        reject(new Error(event.data.error || "OAuth authorization failed"));
                        cleanup();
                    }
                };
                // 检查弹窗是否关闭
                const checkClosed = () => {
                    if (popupRef.current && popupRef.current.closed && !isProcessed) {
                        // 只有在未处理的情况下才认为是用户取消
                        reject(new Error("User cancelled the login process"));
                        cleanup();
                    }
                    else if (popupRef.current && !popupRef.current.closed) {
                        // 继续检查，直到弹窗关闭或处理完成
                        checkClosedInterval = setTimeout(checkClosed, 1000);
                    }
                };
                // 清理函数
                const cleanup = () => {
                    window.removeEventListener("message", handleMessage);
                    if (checkClosedInterval) {
                        clearTimeout(checkClosedInterval);
                    }
                    if (popupRef.current && !popupRef.current.closed) {
                        popupRef.current.close();
                    }
                    popupRef.current = null;
                    popupPromiseRef.current = null;
                };
                // 添加事件监听
                window.addEventListener("message", handleMessage);
                window.addEventListener("storage", async (event) => {
                    isProcessed = true;
                    if (event.key === "GOOGLE_OAUTH_SUCCESS" && event.newValue) {
                        try {
                            // 交换code获取session token
                            await exchangeCodeForSessionToken(event.newValue);
                            resolve();
                        }
                        catch (error) {
                            reject(error);
                        }
                        finally {
                            cleanup();
                            localStorage.removeItem("GOOGLE_OAUTH_SUCCESS");
                        }
                    }
                    if (event.key === "GOOGLE_OAUTH_ERROR" && event.newValue) {
                        reject(new Error(event.newValue || "OAuth authorization failed"));
                        cleanup();
                        localStorage.removeItem("GOOGLE_OAUTH_ERROR");
                    }
                });
                checkClosed();
            });
            return popupPromiseRef.current;
        }
        catch (error) {
            console.error("Popup login failed:", error);
            throw error;
        }
    }, [fetchUser]);
    const exchangeCodeForSessionToken = useCallback((code) => {
        // Ensure we only exchange the code once. In dev, useEffect will run
        // twice, so we need to reuse this promise to avoid multiple exchanges
        // which would otherwise result in a failed request. The failed request
        // sometimes causes the entire flow to break.
        if (exchangeRef.current)
            return exchangeRef.current;
        exchangeRef.current = (async (code) => {
            try {
                const response = await fetch("/api/sessions", {
                    method: "POST",
                    headers: {
                        "Content-Type": "application/json",
                    },
                    body: JSON.stringify({ code }),
                });
                if (!response.ok) {
                    throw new Error(`Failed to exchange code for session token: API responded with HTTP status ${response.status}`);
                }
                // Refetch user after successful code exchange to populate user state
                await fetchUser();
            }
            catch (error) {
                console.error(error);
            }
            finally {
                exchangeRef.current = null;
            }
        })(code);
        return exchangeRef.current;
    }, [fetchUser]);
    // 向父窗口发送OAuth Code
    const notifyParentWindowWithOAuthCode = () => {
        const urlParams = new URLSearchParams(window.location.search);
        const code = urlParams.get("code");
        const error = urlParams.get("error");
        const errorDescription = urlParams.get("error_description");
        if (!code && !error) {
            throw new Error("No OAuth code or error found in URL parameters.");
        }
        const handleSuccess = (successCode) => {
            if (window.opener) {
                window.opener.postMessage({ type: "GOOGLE_OAUTH_SUCCESS", code: successCode }, window.location.origin);
            }
            else {
                localStorage.setItem("GOOGLE_OAUTH_SUCCESS", successCode);
            }
        };
        const handleError = (errorMsg) => {
            if (window.opener) {
                window.opener.postMessage({ type: "GOOGLE_OAUTH_ERROR", error: errorMsg }, window.location.origin);
            }
            else {
                localStorage.setItem("GOOGLE_OAUTH_ERROR", errorMsg);
            }
        };
        if (code) {
            handleSuccess(code);
        }
        else if (error) {
            handleError(errorDescription || error);
        }
        window.close();
    };
    const sendOTP = useCallback(async (email) => {
        const response = await fetch("/api/send-otp", {
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            },
            body: JSON.stringify({ email }),
        });
        const data = await response.json();
        if (data.error) {
            throw new Error(data.error);
        }
        return data;
    }, []);
    const verifyOTP = useCallback(async (email, otp) => {
        const response = await fetch("/api/verify-otp", {
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            },
            body: JSON.stringify({ email, otp }),
        });
        return response.json().then((data) => {
            if (data.error) {
                throw new Error(data.error);
            }
            fetchUser();
            return data;
        });
    }, []);
    useEffect(() => {
        fetchUser().then(() => setIsPending(false), () => setIsPending(false));
    }, []);
    const contextValue = {
        user,
        isPending,
        isFetching,
        fetchUser,
        redirectToLogin,
        popupLogin,
        exchangeCodeForSessionToken,
        notifyParentWindowWithOAuthCode,
        logout,
        sendOTP,
        verifyOTP,
    };
    return _jsx(AuthContext.Provider, {
        value: contextValue,
        children: children,
    });
}
/**
 * A React hook that provides the AuthContextValue.
 * @example
 * const { user } = useAuth();
 */
export function useAuth() {
    const context = useContext(AuthContext);
    if (!context) {
        throw new Error("useAuth must be used within a AuthProvider");
    }
    return context;
}
